<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robot Thinking Expression</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #9c27b0 0%, #673ab7 100%);
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    
    #expression-container {
      position: relative;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    #status-bar {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-size: 12px;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <div id="expression-container">
    <div id="status-bar">
      <span id="connection-status">Thinking Mode</span>
    </div>
    <div id="robot-canvas"></div>
  </div>

  <script>
    let canvas, ctx;
    let animationId;
    let frameCount = 0;
    
    const robotExpression = {
      currentEmotion: 'thinking',
      animationPhase: 0,
      blinkTimer: 0,
      isBlinking: false,
      eyeOpenness: 1.0
    };

    document.addEventListener('DOMContentLoaded', function() {
      initCanvas();
      startAnimation();
      triggerHeadMovement();
    });

    function initCanvas() {
      canvas = document.createElement('canvas');
      canvas.width = 800;
      canvas.height = 600;
      canvas.style.display = 'block';
      canvas.style.maxWidth = '100%';
      canvas.style.maxHeight = '100%';
      
      const container = document.getElementById('robot-canvas');
      container.appendChild(canvas);
      
      ctx = canvas.getContext('2d');
    }

    function triggerHeadMovement() {
      try {
        if (window.Android && window.Android.sendWebSocketMessage) {
          const targetCommand = { command: 'tilt', angle: -3, id: 'thinking_tilt' };
          window.Android.sendWebSocketMessage(JSON.stringify(targetCommand));
          
          setTimeout(() => {
            const neutralCommand = { command: 'tilt', angle: 0, id: 'return_to_neutral' };
            window.Android.sendWebSocketMessage(JSON.stringify(neutralCommand));
          }, 1000);
        }
      } catch (error) {
        console.log('Head movement not available:', error);
      }
    }

    function startAnimation() {
      function animate() {
        updateAnimation();
        draw();
        animationId = requestAnimationFrame(animate);
        frameCount++;
      }
      animate();
    }

    function updateAnimation() {
      robotExpression.animationPhase += 0.03;
      updateBlinking();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawRobotFace();
    }

    function drawBackground() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#9c27b0');
      gradient.addColorStop(1, '#673ab7');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      drawThoughtParticles();
    }

    function drawThoughtParticles() {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      
      for (let i = 0; i < 25; i++) {
        let x = (frameCount * 0.3 + i * 35) % (canvas.width + 50);
        let y = canvas.height/3 + Math.sin(frameCount * 0.02 + i) * 50 + Math.sin(i) * 100;
        let size = 2 + Math.sin(frameCount * 0.04 + i) * 1.5;
        
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawRobotFace() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      ctx.save();
      ctx.translate(centerX, centerY);
      
      drawGlow();
      
      // Main face circle
      ctx.fillStyle = '#e1bee7';
      ctx.strokeStyle = '#9c27b0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, 150, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      drawThinkingEyes();
      drawThinkingMouth();
      drawThoughtBubbles();
      
      ctx.restore();
    }

    function drawGlow() {
      for (let i = 0; i < 8; i++) {
        ctx.fillStyle = `rgba(156, 39, 176, ${0.1})`;
        ctx.beginPath();
        ctx.arc(0, 0, 160 + i * 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawThinkingEyes() {
      const eyeSize = 60;
      const eyeY = -30;
      const eyeSpacing = 60;
      
      // Eyes looking slightly upward when thinking
      drawSingleEye(-eyeSpacing, eyeY - 5, eyeSize, '#9664c8');
      drawSingleEye(eyeSpacing, eyeY - 5, eyeSize, '#9664c8');
    }

    function drawSingleEye(x, y, size, irisColor) {
      ctx.save();
      ctx.translate(x, y);
      
      // Eye white
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#9c27b0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, size/2, (size/2) * robotExpression.eyeOpenness, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Iris (positioned slightly up for thinking look)
      ctx.fillStyle = irisColor;
      const irisSize = size * 0.6;
      ctx.beginPath();
      ctx.ellipse(0, -3, irisSize/2, (irisSize/2) * robotExpression.eyeOpenness, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Pupil
      ctx.fillStyle = '#000000';
      const pupilSize = size * 0.25;
      ctx.beginPath();
      ctx.ellipse(0, -3, pupilSize/2, (pupilSize/2) * robotExpression.eyeOpenness, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      const highlightSize = size * 0.15;
      ctx.beginPath();
      ctx.ellipse(-size * 0.1, -size * 0.15, highlightSize/2, (highlightSize/2) * robotExpression.eyeOpenness, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    function drawThinkingMouth() {
      const mouthY = 45;
      
      // Small contemplative mouth
      ctx.strokeStyle = '#7b1fa2';
      ctx.lineWidth = 3;
      
      ctx.beginPath();
      ctx.moveTo(-8, mouthY);
      ctx.lineTo(8, mouthY);
      ctx.stroke();
    }

    function drawThoughtBubbles() {
      // Thought bubbles floating around
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.strokeStyle = '#ba68c8';
      ctx.lineWidth = 2;
      
      const bubbles = [
        {x: 80, y: -100, size: 12},
        {x: 110, y: -130, size: 18},
        {x: 140, y: -150, size: 25},
        {x: 170, y: -170, size: 30}
      ];
      
      bubbles.forEach((bubble, index) => {
        let y = bubble.y + Math.sin(frameCount * 0.03 + index * 0.5) * 5;
        let alpha = 0.8 + Math.sin(frameCount * 0.04 + index) * 0.2;
        
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(bubble.x, y, bubble.size/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.globalAlpha = 1;
      });
      
      // Question marks inside bubbles
      ctx.fillStyle = '#7b1fa2';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      
      bubbles.slice(1).forEach((bubble, index) => {
        let y = bubble.y + Math.sin(frameCount * 0.03 + (index + 1) * 0.5) * 5;
        if (bubble.size >= 20) {
          ctx.fillText('?', bubble.x, y + 5);
        }
      });
    }

    function updateBlinking() {
      // Thinking eyes blink slowly
      robotExpression.blinkTimer++;
      
      if (robotExpression.blinkTimer > 220) {
        robotExpression.isBlinking = true;
        robotExpression.blinkTimer = 0;
      }
      
      if (robotExpression.isBlinking) {
        if (robotExpression.eyeOpenness > 0) {
          robotExpression.eyeOpenness -= 0.15;
        } else {
          robotExpression.eyeOpenness += 0.15;
          if (robotExpression.eyeOpenness >= 1.0) {
            robotExpression.eyeOpenness = 1.0;
            robotExpression.isBlinking = false;
          }
        }
      }
    }
  </script>
</body>
</html>